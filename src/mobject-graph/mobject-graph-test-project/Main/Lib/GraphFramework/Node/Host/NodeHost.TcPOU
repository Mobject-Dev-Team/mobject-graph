<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="NodeHost" Id="{18596ec7-decd-4431-8b7f-df58d73ea2e5}" SpecialFunc="None">
    <Declaration><![CDATA[{attribute 'linkalways'} 
{attribute 'no_explicit_call' := 'This FB is a CLASS and must be accessed using methods or properties'}
{attribute 'enable_dynamic_creation'}
FUNCTION_BLOCK NodeHost IMPLEMENTS I_Nodes, I_Serializable
VAR
	hostParent : I_HostNodes;
	eventTarget : I_EventTarget;
	nodes : Dictionary;
	nodesInOrder : LinkedList;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Folder Name="Constructor" Id="{e8077057-591e-4384-bc82-c7eb426be654}" />
    <Folder Name="Protected" Id="{39fb5e5e-8e62-4ccc-ae4f-cdf8d5eb5ce9}" />
    <Method Name="Accept" Id="{83533056-ccb0-4a85-98a5-dcc145ca6bfb}">
      <Declaration><![CDATA[METHOD PUBLIC Accept
VAR_INPUT
	Visitor : I_NodeVisitor;
END_VAR
VAR
	enumerator : I_ForwardEnumerator;
	node : I_Node;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[enumerator := nodes.GetEnumerator();

WHILE (enumerator.MoveNext()) DO
	
	IF enumerator.TryGet(node) THEN
		node.Accept(Visitor);
	END_IF

END_WHILE

enumerator.Dispose();]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddNode" Id="{d1bded04-f1d8-4c15-92f8-cbb9151688eb}">
      <Declaration><![CDATA[METHOD PUBLIC AddNode
VAR_INPUT
	Node : I_Node;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[nodes.AddOrUpdate(Node.id, Node);
UpdateExecutionOrder(Node);
EmitOnNodeAddedEvent(Node);]]></ST>
      </Implementation>
    </Method>
    <Method Name="EmitOnNodeAddedEvent" Id="{c4e0373f-d6e4-47dd-b7dc-a31680c50096}" FolderPath="Protected\">
      <Declaration><![CDATA[METHOD PROTECTED EmitOnNodeAddedEvent
VAR_INPUT
	Node : I_Node;
END_VAR
VAR
	pNodeAddedEvent : POINTER TO NodeAddedEvent;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF eventTarget = 0 THEN
	RETURN;
END_IF

pNodeAddedEvent := __NEW(NodeAddedEvent(Target := Node));
eventTarget.Emit('OnNodeAdded',pNodeAddedEvent^);
pNodeAddedEvent^.Dispose();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Execute" Id="{6155e012-e79f-4030-a0e1-1cca3862d2d9}">
      <Declaration><![CDATA[METHOD PUBLIC Execute
VAR_INPUT
END_VAR
VAR
	enumerator : I_ForwardEnumerator;
	node : I_Node;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[enumerator := nodesInOrder.GetEnumerator();

WHILE enumerator.MoveNext() DO
	IF enumerator.TryGet(node) THEN
		node.Execute();
	END_IF
END_WHILE

enumerator.Dispose();]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{d79da06d-3fe9-4db4-8e19-0fc3b7d6f9b4}" FolderPath="Constructor\">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
	bInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)
	Parent : I_HostNodes;
	parentEventTarget : I_EventTarget;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[hostParent := Parent;
eventTarget := parentEventTarget;]]></ST>
      </Implementation>
    </Method>
    <Method Name="RemoveNode" Id="{c092aa2e-ba4e-445b-9f3c-109fa70adaec}">
      <Declaration><![CDATA[METHOD PUBLIC RemoveNode
VAR_INPUT
	Node : I_Node;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[nodes.Remove(Node.Id);
nodesInOrder.Remove(Node);]]></ST>
      </Implementation>
    </Method>
    <Method Name="SerializeWith" Id="{35e41fb7-926c-4bdb-ba3b-2b9824a08186}">
      <Declaration><![CDATA[METHOD PUBLIC SerializeWith
VAR_INPUT
	Serializer : I_Serializer;
END_VAR
VAR
	enumerator : I_ForwardEnumerator;
	node : I_Node;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF nodes.Count = 0 THEN
	RETURN;
END_IF

Serializer.AddKey('nodes');
Serializer.StartArray();

enumerator := nodes.GetEnumerator();

WHILE enumerator.MoveNext() DO
	IF enumerator.TryGet(node) THEN
		node.SerializeWith(Serializer);
	END_IF
END_WHILE

enumerator.Dispose();

Serializer.EndArray();]]></ST>
      </Implementation>
    </Method>
    <Method Name="TryDeserializeFrom" Id="{6fea03a2-3df5-4097-914c-6303dd7019fe}">
      <Declaration><![CDATA[METHOD PUBLIC TryDeserializeFrom : BOOL
VAR_INPUT
	Deserializer : I_Deserializer;
	Feedback : I_DeserializerFeedback;
END_VAR
VAR
	nodeDeserializer : I_Deserializer;
	nodesEnumerator : I_DeserializerArrayForwardEnumerator;
	nodeId : T_MAXSTRING;
	node : I_Node;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[nodeDeserializer := Deserializer.GetKeyArray('nodes');
nodesEnumerator := nodeDeserializer.GetArrayEnumerator();

WHILE nodesEnumerator.MoveNext() DO
	
	IF NOT nodesEnumerator.Current.TryGetKeyString('id',nodeId, Feedback) THEN
		CONTINUE;
	END_IF
	
	IF NOT TryGetNodeById(nodeId, node)THEN
		CONTINUE;
	END_IF
	
	node.TryDeserializeFrom(nodesEnumerator.Current, Feedback);

END_WHILE

nodesEnumerator.Dispose();]]></ST>
      </Implementation>
    </Method>
    <Method Name="TryGetNodeById" Id="{2bff4c58-9fd9-43b5-b3a2-ffaf950a6356}">
      <Declaration><![CDATA[METHOD PUBLIC TryGetNodeById : BOOL
VAR_INPUT
	Id : T_MAXSTRING;
	Destination : REFERENCE TO I_Node;
END_VAR
VAR
	node : I_Node;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT nodes.TryGetValue(Id, node) THEN
	RETURN;
END_IF

Destination := node;
TryGetNodeById := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="UpdateExecutionOrder" Id="{2e22e5f6-6d8c-472d-a3eb-bdc3f467ece6}" FolderPath="Protected\">
      <Declaration><![CDATA[METHOD PROTECTED UpdateExecutionOrder
VAR_INPUT
	Node : I_Node;
END_VAR
VAR
	currentPosition : I_LinkedListNode;
	currentNode : I_Node;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF nodesInOrder.First = 0 THEN
	nodesInOrder.AddFirst(Node);
	RETURN;
END_IF

NodesInOrder.First.TryGet(currentNode); 
IF currentNode.Order > Node.Order THEN
	nodesInOrder.AddFirst(Node);
	RETURN;
END_IF

currentPosition := nodesInOrder.Last;
WHILE (TRUE) DO
	
	currentPosition.TryGet(currentNode); 
	IF currentNode.Order <= Node.Order THEN
		nodesInOrder.AddAfter(currentPosition, Node);
		RETURN;
	END_IF

END_WHILE]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>